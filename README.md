# btc-algo
This project focuses on creating a basic momentum algorithm for trading bitcoin (can eventually be applied to any crypto). This README file will provide a thorough overview of the project, and markdown cells and documentation within the notebook provide further details.

## Abstract
The algorithm I created takes the two different moving average lengths and the time to wait before updating as parameters. Each time the loop updates, it calculates the two moving averages, and if the shorter interval has a greater average price than the larger interval, the full available amount of money in USD will be used to purchase BTC (although it can work for any crypto). I then wrote methods to backtest this algorithm with many different moving average lengths over three different years, in pursuit of the best moving average lengths to use long term. I found that no combination of moving averages beat holding BTC over a two year period, but many moving averages beat BTC over one year periods. If I continue to work on this project, it will be to find a way to predict what moving averages to use for a future short period of time.

## Introduction
I started this project because I wanted to learn how to create a working trading algorithm, and I chose to use cryptocurrencies because Coinbase Pro has a very user-friendly and free API for retreiving data about cryptos. After reading about popular trading algorithms, I chose to experiment with a momentum algorithm due to its simplicity and flexibility. I read that a good way to implement a momentum based algo is to choose two different interval moving averages (e.g. 5 minutes and 20 minutes), and to buy the crypto when the shorter average is higher than the longer average and sell if the opposite occurs. I first coded this algorithm, and then applied it to historic bitcoin data in attempt to optimize the algorithm using the best possible intervals for the moving averages.

## Methods and Results
### Moving Averages Algorithm
The trading algorithm is very simple: it takes the two different moving average lengths and the time to wait before updating as parameters. Each time the loop updates, it calculates the two moving averages, and if the shorter interval has a greater average price than the larger interval, the full available amount of money in USD will be used to purchase BTC (although it can easily be adjusted to work for any crypto). If the shorter interval has a lower average price than the larger interval *and* the value of BTC is greater than when it was last purchased, it will be sold for USD. The reason this works is that when a shorter moving average has a higher value than a longer one, it is indication that the crypto is trending upward and is likely to continue moving up and vice versa. After testing some different moving averages in real time with the Sandbox API, I wondered if I could find specific moving averages that would result in more profit.

### Historical Moving Average Analysis of BTC
#### Methods
To correctly backtest the algorithm I created, I first wrote methods that iterate through a dataframe of historic minutely data of a crypto and create new columns for any given length moving averages. I also wrote a method that factors in the fees that Coinbase charges for transactions for as much accuracy as possible. These methods are helpers for the backtest method, which takes two intervals in minutes, historic data, and a starting amount of USD, then returns the final amount in USD. The method backtest is then used in the method returns_many, which returns a dataframe that contains the final balance of many different moving average lengths chosen by the user. This allowed me to test hundreds of different moving average pairs and look for patterns within that data.

#### Analysis
The first timeframe during which I backtested the algorithm was July 2019 to July 2020. I chose this year to start because BTC stayed a fairly constant price throughout that time span, ending down about 8%. I ran the returns_many method with parameters that allowed it to test every combination of moving average lengths ranging from 200 to 20000 minutes with a skipping interval of 200 minutes (i.e. 200 and 400, 200 and 600,..., 19800 and 20000) for a total of 4950 different moving average algorithms backtested. Many of the moving average combinations resulted in profit and a handful even were up over 40% despite the fact that owning BTC throughout the entire year would result in a loss. I plotted this data in three dimensions with *x<sub>1</sub>* and *x<sub>2</sub>* being the first and second moving average lengths, and *y* being the ending balance. Interestingly, there are some clusters that represent high returns, so I next did this same exact analysis on another year (July 2018 to July 2019). Again, there were many combinations of moving averages that performed far better than holding BTC over that period. However, after making the same plot as from the first backtest, I found limited overlap of the clusters over both trials, and the patterns in the graph looked fairly different. I then selected the moving average combinations that performed best over both years, and their yearly returns were far less than the best combinations of each year (though still better than holding BTC). I took that best combination and backtested it over the enitre BTC history dataset (10/2012 to 3/2021) to find that holding BTC would've resulted in about 390% returns whereas the algorithm only had 10% returns. This further proved that no one set of moving averages can perform well over a very long time.

## Conclusion

After all of this work, I sadly found that it is impossible for one pair of moving average lengths to result in the highest BTC returns longterm. However, I learned many things from this project. I now know about various trading algorithm strategies, have a stronger foundation in pandas, and know about how APIs work. I also know that although none of the algorithms with set moving average lengths beat holding BTC over many years, many of them went up consistantly year-over-year, making them safer short term investments than holding BTC. Additionally, I now have a hypothesis that BTC's volatility may stay relatively similar for some period of time before making a shift. When I have more knowledge of time series and machine learning, I'd like to come back to this project and look for these volatility patterns. With this information, I could create a moving average algorithm that changes what average lengths it uses regularly based on recent volatility patterns.
